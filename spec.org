
* primitives
** PBKDF2 (RFC2898):
   - DK=PBKDF2(P,S,c,dkLen)  [PRF]
   - P: password (string)
   - S: salt (string)
   - c: iteration count (int)
   - dkLen: output length (int, bytes, <=hLen*(2^32-1))
   - DK: derived key (string, len=dkLen)
   - PRF: e.g. HMAC(SHA256), or AES+CBC
   - code:
     - each block is created independently
     - first iteration: U = PRF(P, S+uint64(blocknum)), key=U
     - subsequent iterations: U = PRF(S,U), key=XOR(key,U)
     - (i.e. build a c-long PRF chain, XOR all outputs together)
** scrypt (http://www.tarsnap.com/scrypt.html)
   - DK=out=scrypt(P,S,N,r,p,dkLen) [HMAC_SHA256, Salsa20/8]
   - P: password (string)
   - S: salt (string)
   - N: CPU/memory cost parameter
   - r: block size parameter, paper recommends r=8
   - p: parallelization parameter, paper recommends p=1
   - dkLen: output length (int, bytes, <=hLen*(2^32-1))
   - work:
     - code suggests "128*N*r <= memlimit", and "4*N*r*p < opslimit" for CPU
       time. The scrypt tool does a quick measurement of the local CPU to
       decide what values to use, influenced by input parameters. "opslimit"
       appears to be the number of salsa20/8 core invocations, and is
       constrained to be at least 2^15.
     - compiling with CFLAGS=-DDEBUG displays N/r/p values
     - on work laptop, memlimit=1M timelimit=10s gets N=1024,r=8,p=502
       - it measured 512 salsa20/8 cores taking 310us
       - note that tool requires "-M 100000", not "-M 1M"
       - default (no -M) allows use of 228MB, probably .125*sysmem
     - 10M gets N=8192,r=8,p=63
     - 100M gets N=65536, r=8, p=7
     - let's target 100M and my laptop's CPU, so N=65536, r=8, p=7
** HKDF
   - K1|K2|K3..|Kt = HKDF(XTS, SKM, CTXinfo, L)  [HMAC-SHA256]
   - XTS: Extractor Salt (string)
   - SKM: source key material (string)
   - CTXinfo: (string)
   - L: number of key bits (int)
   - SKM is secret. XTS is random but not-secret. resulting key is bound to
     CTXinfo.
   - code:
     - extract: PRK = HMAC(key=XTS, data=SKM)
     - expand: K1 = HMAC(key=PRK, data=CTXinfo+0)
       - K2 = HMAC(key=PRK, data=K1+CTXinfo+1), etc
** SRP (http://srp.stanford.edu/,
   http://en.wikipedia.org/wiki/Secure_remote_password_protocol)
   - system parameters (q, N, g, k)
   - algorithm choices: SHA-256
   - small random salt s
   - I username
   - p password
*** http://pypi.python.org/pypi/srp

* spec
** inputs:
   - password (string)
   - email (string)
** utilities:
   - encrypt_and_mac(ENC, MAC, data):
     - IV = os.urandom(dkLen)
     - A = AES256-CBC(key=ENC, IV, data)
     - B = HMAC-SHA256(key=MAC, data=concat(IV,A))
     - return IV+A+B
   - decrypt_and_mac(ENC, MAC, encdata)
     - IV=encdata[:32], data = encdata[32:-32], macout = encdata[-32:]
     - check HMAC-SHA256(key=MAC, data=encdata[:-32]) == macout, else fail
     - return AES256-CBC-decrypt(key=ENC, IV, data)
   - make_session_keys(key=SRPKsession)
     - ENC1,MAC2,ENC2,MAC2 = HKDF(SDK=key, XTS=KW5, CTXinfo="", L=4*dkLen)
   - send_request(message)
     - TX = SHA256(SRPKession)+encrypt_and_mac(ENC1,MAC1,message)
     - send HK+TX
     - receive RX
     - return decrypt_and_mac(ENC2,MAC2,RX)
   - receive_request(HKsession, TX) ...
   - unwrap_session(wire, salt)
     - HK = wire[:32], encmsg = wire[32:]
     - look up SRPKsession,email=sessions[HK]
     - ENC,MAC = HKDF(SDK=SRPKsession, XTS=KWses, CTXinfo="", L=2*dkLen)
     - message = decrypt_and_mac(ENC, MAC, encmsg)
     - return email, message
** constants:
   - KW1 = "identity.mozilla.com/keywrapping/v1/1:"
   - KW2 = "identity.mozilla.com/keywrapping/v1/2:", etc KW3, 4, 5
** parameters
   - c1 = 10000 # PBKDF2 iteration count
   - c2 = 10000
   - N,r,p = 32768,8,1  # scrypt 100MB/1.0s, on work laptop
   - dkLen = 256/8 = 32 # bytes
   - algorithm choices: PBKDF uses HMAC-SHA256
** code:
   - compute PWK:
     - A = PBKDF(P=password, S=KW1+email, c=c1)
     - B = scrypt(P=A, S=KW2, N,r,p)
     - C = PBKDF(P=password+B, S=KW3, c=c2)
     - PWK|MAC|SRPpw = HKDF(SKM=C, XTS=KW4, CTXinfo="", L=3*dkLen)
   - create initial UK (done once, during account setup)
     - UK = os.urandom(2*dkLen) # 256 enc + 256 MAC
   - initial key-wrapping setup (done once, during account setup):
     - compute PWK
     - SRPv,SRPsalt = SRP(P=SRPpw, ...) // SRPsalt is short random
     - send (email, SRPv, SRPsalt) safely to server XXX
     - store initial WUK:
       - client:
         - WUK: WUKout = encrypt_and_mac(PWK, MAC, data=UK)
         - perform SRP to get Ksession
           - server remembers H(Ksession)->(Ksession,email) for a little while
         - command = json.stringify(["update", WUKOUT])
         - send(wrap_session(salt=KWtoserver, Ksession, command))
       - server:
         - email,command_s=unwrap_session(salt=KWtoserver, wire)
         - command = json.decode(command_s)
         - if command[0]=="update", store(email, command[1]))
         - response = wrap_session(salt=KWtoclient, Ksession, "ok")
         - return(response)
       - client:
         - ...
   - retrieve WUK (from password)
     - client:
       - send email, retrieve SRPsalt
       - compute PWK (while waiting for SRPsalt)
       - perform SRP to get Ksession
         - server remembers H(Ksession)->(Ksession,email) for a little while
       - command = json.stringify(["read"])
       - send(wrap_session(Ksession, command))
     - server:
       - email,command_s=unwrap_session(wire)
       - command = json.decode(command_s)
       - if command[0]=="read", data=load(email)
       - return response = wrap_session(salt=KWtoclient, Ksession, data)
     - client:
       - data = unwrap_session(data)
       - ...
       - command = json.stringify(["update", IV+WUK, WUKMAC])
       - MSG = encrypt_and_mac(ENCsess, MACsess, data=command)
       - send(MSG)
       - WUK: WUKout = encrypt_and_mac(PWK, MAC, data=UK)
       - 
