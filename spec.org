
* primitives
** PBKDF2 (RFC2898):
   - DK=PBKDF2(P,S,c,dkLen)  [PRF]
   - P: password (string)
   - S: salt (string)
   - c: iteration count (int)
   - dkLen: output length (int, bytes, <=hLen*(2^32-1))
   - DK: derived key (string, len=dkLen)
   - PRF: e.g. HMAC(SHA256), or AES+CBC
   - code:
     - each block is created independently
     - first iteration: U = PRF(P, S+uint64(blocknum)), key=U
     - subsequent iterations: U = PRF(S,U), key=XOR(key,U)
     - (i.e. build a c-long PRF chain, XOR all outputs together)
** scrypt (http://www.tarsnap.com/scrypt.html)
   - DK=out=scrypt(P,S,N,r,p,dkLen) [HMAC_SHA256, Salsa20/8]
   - P: password (string)
   - S: salt (string)
   - N: CPU/memory cost parameter
   - r: block size parameter, paper recommends r=8
   - p: parallelization parameter, paper recommends p=1
   - dkLen: output length (int, bytes, <=hLen*(2^32-1))
   - work:
     - code suggests "128*N*r <= memlimit", and "4*N*r*p < opslimit" for CPU
       time. The scrypt tool does a quick measurement of the local CPU to
       decide what values to use, influenced by input parameters. "opslimit"
       appears to be the number of salsa20/8 core invocations, and is
       constrained to be at least 2^15.
     - compiling with CFLAGS=-DDEBUG displays N/r/p values
     - on work laptop, memlimit=1M timelimit=10s gets N=1024,r=8,p=502
       - it measured 512 salsa20/8 cores taking 310us
       - note that tool requires "-M 100000", not "-M 1M"
       - default (no -M) allows use of 228MB, probably .125*sysmem
     - 10M gets N=8192,r=8,p=63
     - 100M gets N=65536, r=8, p=7
     - let's target 100M and my laptop's CPU, so N=65536, r=8, p=7
** HKDF
   - K1|K2|K3..|Kt = HKDF(XTS, SKM, CTXinfo, L)  [HMAC-SHA256]
   - XTS: Extractor Salt (string)
   - SKM: source key material (string)
   - CTXinfo: (string)
   - L: number of key bits (int)
   - SKM is secret. XTS is random but not-secret. resulting key is bound to
     CTXinfo.
   - code:
     - extract: PRK = HMAC(key=XTS, data=SKM)
     - expand: K1 = HMAC(key=PRK, data=CTXinfo+0)
       - K2 = HMAC(key=PRK, data=K1+CTXinfo+1), etc
** SRP (http://srp.stanford.edu/,
   http://en.wikipedia.org/wiki/Secure_remote_password_protocol)
   - system parameters (q, N, g, k)
   - algorithm choices: SHA-256
   - small random salt s
   - I username
   - p password
*** http://pypi.python.org/pypi/srp

* spec
** inputs:
   - password (string)
   - email (string)
** utilities:
   - A+B: string concatenation: Netstring(A)+Netstring(B)
   - netstring(): "%d:%s." % (len(s), s)
   - plus(*strings): "".join([netstring(s) for s in strings])
   - encrypt_and_mac(ENC, MAC, data):
     - IV = os.urandom(dkLen)
     - A = AES256-CBC(key=ENC, IV, data)
     - B = HMAC-SHA256(key=MAC, data=concat(IV,A))
     - return IV+A+B
** constants:
   - KW1 = "keywrapping-v1@identity.mozilla.com:1"
   - KW2 = "keywrapping-v1@identity.mozilla.com:2"
   - KW3 = "keywrapping-v1@identity.mozilla.com:3"
   - KW3 = "keywrapping-v1@identity.mozilla.com:4"
** parameters
   - c1 = 10000 # PBKDF2 iteration count
   - c2 = 10000
   - N,r,p = 32768,8,1  # scrypt 100MB/1.0s, on work laptop
   - dkLen = 256/8 = 32 # bytes
   - algorithm choices: PBKDF uses HMAC-SHA256
** code:
   - compute PWK:
     - A = PBKDF(P=password, S=KW1+email, c=c1)
     - B = scrypt(P=A, S=KW2, N,r,p)
     - C = PBKDF(P=password+B, S=KW3, c=c2)
     - PWK|MAC|SRPpw = HKDF(SKM=C, XTS=KW4, CTXinfo="", L=3*dkLen)
   - create initial UK (done once, during account setup)
     - UK = os.urandom(2*dkLen) # 256 enc + 256 MAC
   - initial key-wrapping setup (done once, during account setup):
     - compute PWK
     - SRPv,SRPsalt = SRP(P=SRPpw, ...) // SRPsalt is short random
     - send (email, SRPv, SRPsalt) safely to server
     - store initial WUK:
       - WUK: WUKout = encrypt_and_mac(PWK, MAC, data=UK)
       - perform SRP to get Ksession
         - server remembers H(Ksession)->Ksession for a little while
       - ENCsess, MACsess = HKDF(SKM=Ksession, XTS=KW5, CTXinfo=""?, L=2*dkLen)
       - command = json.stringify(["update", WUKOUT])
       - MSG = encrypt_and_mac(ENCsess, MACsess, data=command)
       - send(MSG)
   - retrieve WUK (from password)
     - send email, retrieve SRPsalt
     - compute PWK (while waiting for SRPsalt)
     - perform SRP to get Ksession
       - server remembers H(Ksession)->Ksession for a little while
     - ENCsess, MACsess = HKDF(SKM=Ksession, XTS=KW5, CTXinfo=""?, L=2*dkLen)
     - send command ["read-encrypted", H(Ksession)]
     - get MSG
     -  ...
     - command = json.stringify(["update", IV+WUK, WUKMAC])
     - MSG = encrypt_and_mac(ENCsess, MACsess, data=command)
     - send(MSG)
     - WUK: WUKout = encrypt_and_mac(PWK, MAC, data=UK)
     - 
